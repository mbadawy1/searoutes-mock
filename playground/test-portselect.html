<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PortSelect Component Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0f1a;
            color: #e5e7eb;
            font-family: system-ui, sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // Simple in-memory cache for query results
        const queryCache = new Map();
        const CACHE_SIZE = 10;

        const isLocode = (s) => /^[A-Z]{2}[A-Z]{3}$/.test(s.toUpperCase());

        function PortSelect({
            label,
            value,
            onChange,
            placeholder = "Start typing a country, city, or LOCODE",
            apiBase = "http://localhost:8003/api",
            country,
            disabled,
            id,
        }) {
            const [query, setQuery] = useState(value || "");
            const [open, setOpen] = useState(false);
            const [items, setItems] = useState([]);
            const [loading, setLoading] = useState(false);
            const [active, setActive] = useState(-1);
            const [error, setError] = useState({ hasError: false, message: "", canRetry: false });
            const boxRef = useRef(null);
            const inputRef = useRef(null);
            const abortRef = useRef(null);
            const timeoutRef = useRef(null);

            // Cache management helpers
            const getCachedResults = (cacheKey) => {
                return queryCache.get(cacheKey) || null;
            };

            const setCachedResults = (cacheKey, results) => {
                if (queryCache.size >= CACHE_SIZE) {
                    const firstKey = queryCache.keys().next().value;
                    queryCache.delete(firstKey);
                }
                queryCache.set(cacheKey, results);
            };

            const clearError = () => {
                setError({ hasError: false, message: "", canRetry: false });
            };

            const setErrorState = (message, canRetry = true) => {
                setError({ hasError: true, message, canRetry });
                setLoading(false);
                setItems([]);
                setOpen(false);
                console.error('PortSelect error:', message);
            };

            // Keep input in sync if parent changes value externally
            useEffect(() => {
                if (value && value !== query) setQuery(value);
            }, [value]);

            // Close when clicking outside
            useEffect(() => {
                const onDocClick = (e) => {
                    if (!boxRef.current) return;
                    if (!boxRef.current.contains(e.target)) setOpen(false);
                };
                document.addEventListener("mousedown", onDocClick);
                return () => document.removeEventListener("mousedown", onDocClick);
            }, []);

            // Cleanup on unmount
            useEffect(() => {
                return () => {
                    if (abortRef.current) {
                        abortRef.current.abort();
                    }
                    if (timeoutRef.current) {
                        clearTimeout(timeoutRef.current);
                    }
                };
            }, []);

            // Enhanced debounced search with timeout, caching, and error handling
            useEffect(() => {
                const q = query.trim();
                
                // Clear error when starting new search
                if (error.hasError) {
                    clearError();
                }

                // Reset state for short queries or direct LOCODEs
                if (q.length < 2 || isLocode(q)) {
                    setItems([]);
                    setOpen(false);
                    setLoading(false);
                    return;
                }

                // Create cache key
                const cacheKey = `${q}${country ? `_${country}` : ''}`;
                
                // Check cache first
                const cached = getCachedResults(cacheKey);
                if (cached) {
                    setItems(cached);
                    setOpen(cached.length > 0);
                    setLoading(false);
                    return;
                }

                setLoading(true);
                setActive(-1);

                // Abort previous request
                if (abortRef.current) {
                    abortRef.current.abort();
                }
                
                // Clear previous timeout
                if (timeoutRef.current) {
                    clearTimeout(timeoutRef.current);
                }

                const ctrl = new AbortController();
                abortRef.current = ctrl;

                // Set up 6-second timeout
                const hardTimeout = setTimeout(() => {
                    ctrl.abort();
                    setErrorState("Search timed out. Please check your connection and try again.", true);
                }, 6000);

                const debounceTimeout = setTimeout(async () => {
                    try {
                        const url = new URL(`${apiBase}/ports/search`);
                        url.searchParams.set("q", q);
                        if (country) url.searchParams.set("country", country);
                        
                        const res = await fetch(url.toString(), { signal: ctrl.signal });
                        
                        if (!res.ok) {
                            throw new Error(`Server error: ${res.status} ${res.statusText}`);
                        }
                        
                        const data = await res.json();
                        const results = Array.isArray(data) ? data : [];
                        
                        // Cache successful results
                        setCachedResults(cacheKey, results);
                        
                        setItems(results);
                        setOpen(results.length > 0);
                        setLoading(false);
                        
                    } catch (err) {
                        if (err.name === 'AbortError') {
                            // Request was aborted, don't show error
                            return;
                        }
                        setErrorState(err.message, true);
                    } finally {
                        clearTimeout(hardTimeout);
                    }
                }, 250);

                return () => {
                    clearTimeout(debounceTimeout);
                    clearTimeout(hardTimeout);
                    ctrl.abort();
                };
            }, [query, apiBase, country, error.hasError]);

            const pick = (locode) => {
                onChange(locode.toUpperCase());
                setQuery(locode.toUpperCase());
                setOpen(false);
                setActive(-1);
                inputRef.current?.blur();
            };

            const onKeyDown = (e) => {
                if (e.key === "Escape") {
                    e.preventDefault();
                    setOpen(false);
                    setActive(-1);
                    return;
                }

                if (!open || items.length === 0) return;
                
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    setActive((i) => (i + 1) % items.length);
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    setActive((i) => (i <= 0 ? items.length - 1 : i - 1));
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    const choice = items[active] || items[0];
                    if (choice) pick(choice.locode);
                } else if (e.key === "Tab") {
                    // Tab confirms highlighted item if available
                    if (active >= 0 && items[active]) {
                        e.preventDefault();
                        pick(items[active].locode);
                    }
                }
            };

            const handleRetry = () => {
                clearError();
                setQuery("");
                setTimeout(() => setQuery(query.trim()), 10);
            };

            const helper = useMemo(() => {
                if (error.hasError) {
                    return { text: error.message, isError: true, canRetry: error.canRetry };
                }
                if (isLocode(query)) {
                    return { text: "Valid UN/LOCODE", isError: false, canRetry: false };
                }
                if (loading) {
                    return { text: "Searching…", isError: false, canRetry: false };
                }
                if (open && items.length === 0 && query.length >= 2) {
                    return { text: "No matches found", isError: false, canRetry: false };
                }
                return { text: "", isError: false, canRetry: false };
            }, [query, loading, open, items, error]);

            const highlightMatch = (text, query) => {
                if (!query || query.length < 2) return text;
                
                const index = text.toLowerCase().indexOf(query.toLowerCase());
                if (index === -1) return text;
                
                return React.createElement(React.Fragment, null,
                    text.slice(0, index),
                    React.createElement("strong", { 
                        style: { fontWeight: 600, color: "#3b82f6" }
                    }, text.slice(index, index + query.length)),
                    text.slice(index + query.length)
                );
            };

            return React.createElement("div", { ref: boxRef, style: { position: "relative" } },
                React.createElement("label", { 
                    style: { display: "block", fontSize: 12, color: "#94a3b8", marginBottom: 6 }
                }, label),
                React.createElement("input", {
                    ref: inputRef,
                    id: id,
                    type: "text",
                    autoComplete: "off",
                    spellCheck: false,
                    placeholder: placeholder,
                    value: query,
                    disabled: disabled,
                    onChange: (e) => {
                        const v = e.target.value;
                        setQuery(v);
                        if (isLocode(v)) {
                            onChange(v.toUpperCase());
                        }
                    },
                    onFocus: () => setOpen(items.length > 0),
                    onKeyDown: onKeyDown,
                    style: {
                        width: "100%",
                        borderRadius: 12,
                        background: "#0b1020",
                        border: "1px solid rgba(255,255,255,.12)",
                        color: "#e5e7eb",
                        padding: "10px 12px",
                        outline: "none",
                        fontSize: "14px",
                    }
                }),
                React.createElement("div", { 
                    style: { fontSize: 12, marginTop: 4, minHeight: 18, display: "flex", alignItems: "center", gap: 8 }
                },
                    React.createElement("span", { 
                        style: { color: helper.isError ? "#ef4444" : "#94a3b8" }
                    }, helper.text),
                    helper.canRetry && React.createElement("button", {
                        type: "button",
                        onClick: handleRetry,
                        style: {
                            background: "transparent",
                            border: "1px solid #ef4444",
                            color: "#ef4444",
                            borderRadius: 4,
                            padding: "2px 6px",
                            fontSize: 10,
                            cursor: "pointer",
                            fontWeight: 500,
                        }
                    }, "Retry")
                ),

                open && items.length > 0 && React.createElement("div", {
                    role: "listbox",
                    "aria-label": "Port suggestions",
                    style: {
                        position: "absolute",
                        left: 0,
                        right: 0,
                        zIndex: 20,
                        background: "#0b1222",
                        border: "1px solid rgba(255,255,255,.12)",
                        borderRadius: 12,
                        maxHeight: 240,
                        overflowY: "auto",
                    }
                },
                    items.map((p, i) => {
                        const isActive = i === active;
                        const q = query.trim();
                        return React.createElement("div", {
                            key: `${p.locode}-${i}`,
                            role: "option",
                            "aria-selected": isActive,
                            onMouseDown: (e) => e.preventDefault(),
                            onClick: () => pick(p.locode),
                            onMouseEnter: () => setActive(i),
                            style: {
                                padding: "10px 12px",
                                cursor: "pointer",
                                background: isActive ? "#1e293b" : "transparent",
                                borderBottom: "1px solid rgba(255,255,255,.06)",
                            }
                        },
                            React.createElement("div", { 
                                style: { display: "flex", justifyContent: "space-between", alignItems: "center", gap: 12 }
                            },
                                React.createElement("div", { style: { flex: 1 } },
                                    React.createElement("div", { 
                                        style: { fontSize: "14px", fontWeight: 500, marginBottom: 2 }
                                    }, highlightMatch(p.name, q), ` (${p.country})`),
                                    React.createElement("div", { 
                                        style: { fontSize: "12px", color: "#94a3b8", fontFamily: "monospace" }
                                    }, p.locode)
                                ),
                                p.countryName && React.createElement("div", { 
                                    style: { fontSize: "12px", color: "#64748b", fontStyle: "italic" }
                                }, p.countryName)
                            )
                        );
                    })
                )
            );
        }

        function TestApp() {
            const [selectedPort, setSelectedPort] = useState("");
            const [selectedPort2, setSelectedPort2] = useState("");

            return React.createElement("div", null,
                React.createElement("h1", { 
                    style: { marginBottom: "24px", fontSize: "28px", fontWeight: 700 }
                }, "Enhanced PortSelect Component Test"),
                
                React.createElement("div", { 
                    style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "20px", marginBottom: "24px" }
                },
                    React.createElement("div", null,
                        React.createElement(PortSelect, {
                            label: "From Port",
                            value: selectedPort,
                            onChange: setSelectedPort,
                            placeholder: "Start typing a country, city, or LOCODE"
                        })
                    ),
                    React.createElement("div", null,
                        React.createElement(PortSelect, {
                            label: "To Port", 
                            value: selectedPort2,
                            onChange: setSelectedPort2,
                            placeholder: "Start typing a country, city, or LOCODE"
                        })
                    )
                ),

                React.createElement("div", { style: { marginTop: "20px", padding: "16px", background: "#0b1222", borderRadius: 12 } },
                    React.createElement("h3", { style: { marginTop: 0, color: "#3b82f6" } }, "Test Instructions:"),
                    React.createElement("ul", { style: { fontSize: "14px", lineHeight: 1.6 } },
                        React.createElement("li", null, "Type 'alex' to search for Alexandria"),
                        React.createElement("li", null, "Use ↑/↓ arrow keys to navigate results"),
                        React.createElement("li", null, "Press Enter or Tab to select highlighted item"),
                        React.createElement("li", null, "Press Esc to close the dropdown"),
                        React.createElement("li", null, "Try typing 'EGALY' directly (valid LOCODE)"),
                        React.createElement("li", null, "Test error handling by stopping the backend server")
                    )
                ),

                React.createElement("div", { style: { marginTop: "20px", padding: "16px", background: "#0f172a", borderRadius: 12 } },
                    React.createElement("h3", { style: { marginTop: 0, color: "#10b981" } }, "Selected Values:"),
                    React.createElement("p", { style: { fontSize: "14px", fontFamily: "monospace" } },
                        "From Port: ", selectedPort || "(none)"
                    ),
                    React.createElement("p", { style: { fontSize: "14px", fontFamily: "monospace" } },
                        "To Port: ", selectedPort2 || "(none)"
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(TestApp));
    </script>
</body>
</html>