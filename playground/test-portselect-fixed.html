<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PortSelect Component Test - FIXED</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0f1a;
            color: #e5e7eb;
            font-family: system-ui, sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // Simple in-memory cache for query results
        const queryCache = new Map();
        const CACHE_SIZE = 10;

        const isLocode = (s) => /^[A-Z]{2}[A-Z]{3}$/.test(s.toUpperCase());

        function PortSelect({
            label,
            value,
            onChange,
            placeholder = "Start typing a country, city, or LOCODE",
            apiBase = "http://localhost:8003/api",
            country,
            disabled,
            id,
        }) {
            const [query, setQuery] = useState(value || "");
            const [open, setOpen] = useState(false);
            const [items, setItems] = useState([]);
            const [loading, setLoading] = useState(false);
            const [active, setActive] = useState(-1);
            const [error, setError] = useState({ hasError: false, message: "", canRetry: false });
            const boxRef = useRef(null);
            const inputRef = useRef(null);
            const abortRef = useRef(null);

            // Cache management helpers
            const getCachedResults = useCallback((cacheKey) => {
                return queryCache.get(cacheKey) || null;
            }, []);

            const setCachedResults = useCallback((cacheKey, results) => {
                if (queryCache.size >= CACHE_SIZE) {
                    const firstKey = queryCache.keys().next().value;
                    queryCache.delete(firstKey);
                }
                queryCache.set(cacheKey, results);
            }, []);

            const clearError = useCallback(() => {
                setError({ hasError: false, message: "", canRetry: false });
            }, []);

            const setErrorState = useCallback((message, canRetry = true) => {
                setError({ hasError: true, message, canRetry });
                setLoading(false);
                setItems([]);
                setOpen(false);
                console.error('PortSelect error:', message);
            }, []);

            // Keep input in sync if parent changes value externally
            useEffect(() => {
                if (value && value !== query) setQuery(value);
            }, [value]);

            // Close when clicking outside
            useEffect(() => {
                const onDocClick = (e) => {
                    if (!boxRef.current) return;
                    if (!boxRef.current.contains(e.target)) {
                        setOpen(false);
                        setActive(-1);
                    }
                };
                document.addEventListener("mousedown", onDocClick);
                return () => document.removeEventListener("mousedown", onDocClick);
            }, []);

            // Cleanup on unmount
            useEffect(() => {
                return () => {
                    if (abortRef.current) {
                        abortRef.current.abort();
                    }
                };
            }, []);

            // Search function
            const performSearch = useCallback(async (searchQuery, controller) => {
                try {
                    const url = new URL(`${apiBase}/ports/search`);
                    url.searchParams.set("q", searchQuery);
                    if (country) url.searchParams.set("country", country);
                    
                    const res = await fetch(url.toString(), { 
                        signal: controller.signal,
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    
                    if (!res.ok) {
                        throw new Error(`Server error: ${res.status} ${res.statusText}`);
                    }
                    
                    const data = await res.json();
                    return Array.isArray(data) ? data : [];
                    
                } catch (err) {
                    if (err.name === 'AbortError') {
                        throw err; // Re-throw abort errors
                    }
                    throw new Error(err.message || "Network error occurred");
                }
            }, [apiBase, country]);

            // Enhanced debounced search with timeout, caching, and error handling
            useEffect(() => {
                const q = query.trim();
                
                // Clear error when starting new search
                if (error.hasError) {
                    clearError();
                }

                // Reset state for short queries or direct LOCODEs
                if (q.length < 2 || isLocode(q)) {
                    setItems([]);
                    setOpen(false);
                    setLoading(false);
                    return;
                }

                // Create cache key
                const cacheKey = `${q}${country ? `_${country}` : ''}`;
                
                // Check cache first
                const cached = getCachedResults(cacheKey);
                if (cached) {
                    setItems(cached);
                    setOpen(cached.length > 0);
                    setLoading(false);
                    return;
                }

                setLoading(true);
                setActive(-1);

                // Abort previous request
                if (abortRef.current) {
                    abortRef.current.abort();
                }

                const controller = new AbortController();
                abortRef.current = controller;

                // Set up 6-second timeout
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    setErrorState("Search timed out. Please check your connection and try again.", true);
                }, 6000);

                const debounceTimeout = setTimeout(async () => {
                    try {
                        const results = await performSearch(q, controller);
                        
                        // Only update state if this request wasn't aborted
                        if (!controller.signal.aborted) {
                            // Cache successful results
                            setCachedResults(cacheKey, results);
                            
                            setItems(results);
                            setOpen(results.length > 0);
                            setLoading(false);
                        }
                        
                    } catch (err) {
                        if (err.name !== 'AbortError' && !controller.signal.aborted) {
                            setErrorState(err.message, true);
                        }
                    } finally {
                        clearTimeout(timeoutId);
                    }
                }, 250);

                return () => {
                    clearTimeout(debounceTimeout);
                    clearTimeout(timeoutId);
                    controller.abort();
                };
            }, [query, performSearch, getCachedResults, setCachedResults, clearError, setErrorState, error.hasError, country]);

            const pick = useCallback((locode) => {
                onChange(locode.toUpperCase());
                setQuery(locode.toUpperCase());
                setOpen(false);
                setActive(-1);
                inputRef.current?.blur();
            }, [onChange]);

            const onKeyDown = useCallback((e) => {
                if (e.key === "Escape") {
                    e.preventDefault();
                    setOpen(false);
                    setActive(-1);
                    return;
                }

                if (!open || items.length === 0) return;
                
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    setActive((i) => (i + 1) % items.length);
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    setActive((i) => (i <= 0 ? items.length - 1 : i - 1));
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    const choice = items[active] || items[0];
                    if (choice) pick(choice.locode);
                } else if (e.key === "Tab") {
                    // Tab confirms highlighted item if available
                    if (active >= 0 && items[active]) {
                        e.preventDefault();
                        pick(items[active].locode);
                    }
                }
            }, [open, items, active, pick]);

            const handleRetry = useCallback(() => {
                clearError();
                const currentQuery = query.trim();
                setQuery(""); // Clear and re-trigger search
                setTimeout(() => setQuery(currentQuery), 10);
            }, [query, clearError]);

            const helper = useMemo(() => {
                if (error.hasError) {
                    return { text: error.message, isError: true, canRetry: error.canRetry };
                }
                if (isLocode(query)) {
                    return { text: "Valid UN/LOCODE", isError: false, canRetry: false };
                }
                if (loading) {
                    return { text: "Searchingâ€¦", isError: false, canRetry: false };
                }
                if (open && items.length === 0 && query.length >= 2) {
                    return { text: "No matches found", isError: false, canRetry: false };
                }
                return { text: "", isError: false, canRetry: false };
            }, [query, loading, open, items, error]);

            const highlightMatch = useCallback((text, query) => {
                if (!query || query.length < 2) return text;
                
                const index = text.toLowerCase().indexOf(query.toLowerCase());
                if (index === -1) return text;
                
                return React.createElement(React.Fragment, null,
                    text.slice(0, index),
                    React.createElement("strong", { 
                        style: { fontWeight: 600, color: "#3b82f6" }
                    }, text.slice(index, index + query.length)),
                    text.slice(index + query.length)
                );
            }, []);

            const handleInputChange = useCallback((e) => {
                const v = e.target.value;
                setQuery(v);
                if (isLocode(v)) {
                    onChange(v.toUpperCase());
                }
            }, [onChange]);

            const handleFocus = useCallback(() => {
                if (items.length > 0) {
                    setOpen(true);
                }
            }, [items.length]);

            return React.createElement("div", { ref: boxRef, style: { position: "relative" } },
                React.createElement("label", { 
                    style: { display: "block", fontSize: 12, color: "#94a3b8", marginBottom: 6 }
                }, label),
                React.createElement("input", {
                    ref: inputRef,
                    id: id,
                    type: "text",
                    autoComplete: "off",
                    spellCheck: false,
                    placeholder: placeholder,
                    value: query,
                    disabled: disabled,
                    onChange: handleInputChange,
                    onFocus: handleFocus,
                    onKeyDown: onKeyDown,
                    style: {
                        width: "100%",
                        borderRadius: 12,
                        background: "#0b1020",
                        border: "1px solid rgba(255,255,255,.12)",
                        color: "#e5e7eb",
                        padding: "10px 12px",
                        outline: "none",
                        fontSize: "14px",
                    }
                }),
                React.createElement("div", { 
                    style: { fontSize: 12, marginTop: 4, minHeight: 18, display: "flex", alignItems: "center", gap: 8 }
                },
                    React.createElement("span", { 
                        style: { color: helper.isError ? "#ef4444" : "#94a3b8" }
                    }, helper.text),
                    helper.canRetry && React.createElement("button", {
                        type: "button",
                        onClick: handleRetry,
                        style: {
                            background: "transparent",
                            border: "1px solid #ef4444",
                            color: "#ef4444",
                            borderRadius: 4,
                            padding: "2px 6px",
                            fontSize: 10,
                            cursor: "pointer",
                            fontWeight: 500,
                        }
                    }, "Retry")
                ),

                open && items.length > 0 && React.createElement("div", {
                    role: "listbox",
                    "aria-label": "Port suggestions",
                    style: {
                        position: "absolute",
                        left: 0,
                        right: 0,
                        zIndex: 20,
                        background: "#0b1222",
                        border: "1px solid rgba(255,255,255,.12)",
                        borderRadius: 12,
                        maxHeight: 240,
                        overflowY: "auto",
                    }
                },
                    items.map((p, i) => {
                        const isActive = i === active;
                        const q = query.trim();
                        return React.createElement("div", {
                            key: `${p.locode}-${i}`,
                            role: "option",
                            "aria-selected": isActive,
                            onMouseDown: (e) => e.preventDefault(),
                            onClick: () => pick(p.locode),
                            onMouseEnter: () => setActive(i),
                            style: {
                                padding: "10px 12px",
                                cursor: "pointer",
                                background: isActive ? "#1e293b" : "transparent",
                                borderBottom: "1px solid rgba(255,255,255,.06)",
                            }
                        },
                            React.createElement("div", { 
                                style: { display: "flex", justifyContent: "space-between", alignItems: "center", gap: 12 }
                            },
                                React.createElement("div", { style: { flex: 1 } },
                                    React.createElement("div", { 
                                        style: { fontSize: "14px", fontWeight: 500, marginBottom: 2 }
                                    }, highlightMatch(p.name, q), ` (${p.country})`),
                                    React.createElement("div", { 
                                        style: { fontSize: "12px", color: "#94a3b8", fontFamily: "monospace" }
                                    }, p.locode)
                                ),
                                p.countryName && React.createElement("div", { 
                                    style: { fontSize: "12px", color: "#64748b", fontStyle: "italic" }
                                }, p.countryName)
                            )
                        );
                    })
                )
            );
        }

        function TestApp() {
            const [selectedPort, setSelectedPort] = useState("");
            const [selectedPort2, setSelectedPort2] = useState("");

            return React.createElement("div", null,
                React.createElement("h1", { 
                    style: { marginBottom: "24px", fontSize: "28px", fontWeight: 700 }
                }, "ðŸ”§ FIXED PortSelect Component Test"),
                
                React.createElement("div", { 
                    style: { marginBottom: "20px", padding: "16px", background: "#10b981", color: "#000", borderRadius: 12, fontWeight: 600 }
                }, "âœ… FIXED: CORS issues, request loops, abort controller, and state management"),

                React.createElement("div", { 
                    style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "20px", marginBottom: "24px" }
                },
                    React.createElement("div", null,
                        React.createElement(PortSelect, {
                            label: "From Port",
                            value: selectedPort,
                            onChange: setSelectedPort,
                            placeholder: "Start typing a country, city, or LOCODE"
                        })
                    ),
                    React.createElement("div", null,
                        React.createElement(PortSelect, {
                            label: "To Port", 
                            value: selectedPort2,
                            onChange: setSelectedPort2,
                            placeholder: "Start typing a country, city, or LOCODE"
                        })
                    )
                ),

                React.createElement("div", { style: { marginTop: "20px", padding: "16px", background: "#0b1222", borderRadius: 12 } },
                    React.createElement("h3", { style: { marginTop: 0, color: "#3b82f6" } }, "Test Instructions:"),
                    React.createElement("ul", { style: { fontSize: "14px", lineHeight: 1.6 } },
                        React.createElement("li", null, "âœ… Type 'alex' â†’ should show Alexandria immediately"),
                        React.createElement("li", null, "âœ… Use â†‘/â†“ arrow keys â†’ should navigate smoothly"),
                        React.createElement("li", null, "âœ… Press Enter or Tab â†’ should select and close"),
                        React.createElement("li", null, "âœ… Press Esc â†’ should close dropdown"),
                        React.createElement("li", null, "âœ… Type 'EGALY' directly â†’ should show 'Valid UN/LOCODE'"),
                        React.createElement("li", null, "âœ… No infinite loops â†’ check browser console for no errors")
                    )
                ),

                React.createElement("div", { style: { marginTop: "20px", padding: "16px", background: "#0f172a", borderRadius: 12 } },
                    React.createElement("h3", { style: { marginTop: 0, color: "#10b981" } }, "Selected Values:"),
                    React.createElement("p", { style: { fontSize: "14px", fontFamily: "monospace" } },
                        "From Port: ", selectedPort || "(none)"
                    ),
                    React.createElement("p", { style: { fontSize: "14px", fontFamily: "monospace" } },
                        "To Port: ", selectedPort2 || "(none)"
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(TestApp));
    </script>
</body>
</html>