<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PortSelect Component Test - FIXED</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0f1a;
            color: #e5e7eb;
            font-family: system-ui, sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // Simple in-memory cache for query results
        const queryCache = new Map();
        const CACHE_SIZE = 10;

        const isLocode = (s) => /^[A-Z]{2}[A-Z]{3}$/.test(s.toUpperCase());

        function PortSelect({
            label,
            value,
            onChange,
            placeholder = "Start typing a country, city, or LOCODE",
            apiBase = "http://localhost:8003/api",
            country,
            disabled,
            id,
        }) {
            const [query, setQuery] = useState(value || "");
            const [open, setOpen] = useState(false);
            const [items, setItems] = useState([]);
            const [loading, setLoading] = useState(false);
            const [active, setActive] = useState(-1);
            const [error, setError] = useState({ hasError: false, message: "", canRetry: false });
            const boxRef = useRef(null);
            const inputRef = useRef(null);
            const abortRef = useRef(null);

            // Cache management helpers
            const getCachedResults = useCallback((cacheKey) => {
                return queryCache.get(cacheKey) || null;
            }, []);

            const setCachedResults = useCallback((cacheKey, results) => {
                if (queryCache.size >= CACHE_SIZE) {
                    const firstKey = queryCache.keys().next().value;
                    queryCache.delete(firstKey);
                }
                queryCache.set(cacheKey, results);
            }, []);

            const clearError = useCallback(() => {
                setError({ hasError: false, message: "", canRetry: false });
            }, []);

            const setErrorState = useCallback((message, canRetry = true) => {
                setError({ hasError: true, message, canRetry });
                setLoading(false);
                setItems([]);
                setOpen(false);
                console.error('PortSelect error:', message);
            }, []);

            // Keep input in sync if parent changes value externally
            useEffect(() => {
                if (value && value !== query) setQuery(value);
            }, [value]);

            // Close when clicking outside
            useEffect(() => {
                const onDocClick = (e) => {
                    if (!boxRef.current) return;
                    if (!boxRef.current.contains(e.target)) {
                        setOpen(false);
                        setActive(-1);
                    }
                };
                document.addEventListener("mousedown", onDocClick);
                return () => document.removeEventListener("mousedown", onDocClick);
            }, []);

            // Cleanup on unmount
            useEffect(() => {
                return () => {
                    if (abortRef.current) {
                        abortRef.current.abort();
                    }
                };
            }, []);

            // Search function
            const performSearch = useCallback(async (searchQuery, controller) => {
                try {
                    const url = new URL(`${apiBase}/ports/search`);
                    url.searchParams.set("q", searchQuery);
                    if (country) url.searchParams.set("country", country);
                    
                    const res = await fetch(url.toString(), { 
                        signal: controller.signal,
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    
                    if (!res.ok) {
                        throw new Error(`Server error: ${res.status} ${res.statusText}`);
                    }
                    
                    const data = await res.json();
                    return Array.isArray(data) ? data : [];
                    
                } catch (err) {
                    if (err.name === 'AbortError') {
                        throw err; // Re-throw abort errors
                    }
                    throw new Error(err.message || "Network error occurred");
                }
            }, [apiBase, country]);

            // Enhanced debounced search with timeout, caching, and error handling
            useEffect(() => {
                const q = query.trim();
                
                // Clear error when starting new search
                if (error.hasError) {
                    clearError();
                }

                // Reset state for short queries or direct LOCODEs
                if (q.length < 2 || isLocode(q)) {
                    setItems([]);
                    setOpen(false);
                    setLoading(false);
                    return;
                }

                // Create cache key
                const cacheKey = `${q}${country ? `_${country}` : ''}`;
                
                // Check cache first
                const cached = getCachedResults(cacheKey);
                if (cached) {
                    setItems(cached);
                    setOpen(cached.length > 0);
                    setLoading(false);
                    return;
                }

                setLoading(true);
                setActive(-1);

                // Abort previous request
                if (abortRef.current) {
                    abortRef.current.abort();
                }

                const controller = new AbortController();
                abortRef.current = controller;

                // Set up 6-second timeout
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    setErrorState("Search timed out. Please check your connection and try again.", true);
                }, 6000);

                const debounceTimeout = setTimeout(async () => {
                    try {
                        const results = await performSearch(q, controller);
                        
                        // Only update state if this request wasn't aborted
                        if (!controller.signal.aborted) {
                            // Cache successful results
                            setCachedResults(cacheKey, results);
                            
                            setItems(results);
                            setOpen(results.length > 0);
                            setLoading(false);
                        }
                        
                    } catch (err) {
                        if (err.name !== 'AbortError' && !controller.signal.aborted) {
                            setErrorState(err.message, true);
                        }
                    } finally {
                        clearTimeout(timeoutId);
                    }
                }, 250);

                return () => {
                    clearTimeout(debounceTimeout);
                    clearTimeout(timeoutId);
                    controller.abort();
                };
            }, [query, performSearch, getCachedResults, setCachedResults, clearError, setErrorState, error.hasError, country]);

            const pick = useCallback((locode) => {
                onChange(locode.toUpperCase());
                setQuery(locode.toUpperCase());
                setOpen(false);
                setActive(-1);
                inputRef.current?.blur();
            }, [onChange]);

            const onKeyDown = useCallback((e) => {
                if (e.key === "Escape") {
                    e.preventDefault();
                    setOpen(false);
                    setActive(-1);
                    return;
                }

                if (!open || items.length === 0) return;
                
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    setActive((i) => (i + 1) % items.length);
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    setActive((i) => (i <= 0 ? items.length - 1 : i - 1));
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    const choice = items[active] || items[0];
                    if (choice) pick(choice.locode);
                } else if (e.key === "Tab") {
                    // Tab confirms highlighted item if available
                    if (active >= 0 && items[active]) {
                        e.preventDefault();
                        pick(items[active].locode);
                    }
                }
            }, [open, items, active, pick]);

            const handleRetry = useCallback(() => {
                clearError();
                const currentQuery = query.trim();
                setQuery(""); // Clear and re-trigger search
                setTimeout(() => setQuery(currentQuery), 10);
            }, [query, clearError]);

            const helper = useMemo(() => {
                if (error.hasError) {
                    return { text: error.message, isError: true, canRetry: error.canRetry };
                }
                if (isLocode(query)) {
                    return { text: "Valid UN/LOCODE", isError: false, canRetry: false };
                }
                if (loading) {
                    return { text: "Searching…", isError: false, canRetry: false };
                }
                if (open && items.length === 0 && query.length >= 2) {
                    return { text: "No matches found", isError: false, canRetry: false };
                }
                return { text: "", isError: false, canRetry: false };
            }, [query, loading, open, items, error]);

            const highlightMatch = useCallback((text, query) => {
                if (!query || query.length < 2) return text;
                
                const index = text.toLowerCase().indexOf(query.toLowerCase());
                if (index === -1) return text;
                
                return React.createElement(React.Fragment, null,
                    text.slice(0, index),
                    React.createElement("strong", { 
                        style: { fontWeight: 600, color: "#3b82f6" }
                    }, text.slice(index, index + query.length)),
                    text.slice(index + query.length)
                );
            }, []);

            const handleInputChange = useCallback((e) => {
                const v = e.target.value;
                setQuery(v);
                if (isLocode(v)) {
                    onChange(v.toUpperCase());
                }
            }, [onChange]);

            const handleFocus = useCallback(() => {
                if (items.length > 0) {
                    setOpen(true);
                }
            }, [items.length]);

            return React.createElement("div", { ref: boxRef, style: { position: "relative" } },
                React.createElement("label", { 
                    style: { display: "block", fontSize: 12, color: "#94a3b8", marginBottom: 6 }
                }, label),
                React.createElement("input", {
                    ref: inputRef,
                    id: id,
                    type: "text",
                    autoComplete: "off",
                    spellCheck: false,
                    placeholder: placeholder,
                    value: query,
                    disabled: disabled,
                    onChange: handleInputChange,
                    onFocus: handleFocus,
                    onKeyDown: onKeyDown,
                    style: {
                        width: "100%",
                        borderRadius: 12,
                        background: "#0b1020",
                        border: "1px solid rgba(255,255,255,.12)",
                        color: "#e5e7eb",
                        padding: "10px 12px",
                        outline: "none",
                        fontSize: "14px",
                    }
                }),
                React.createElement("div", { 
                    style: { fontSize: 12, marginTop: 4, minHeight: 18, display: "flex", alignItems: "center", gap: 8 }
                },
                    React.createElement("span", { 
                        style: { color: helper.isError ? "#ef4444" : "#94a3b8" }
                    }, helper.text),
                    helper.canRetry && React.createElement("button", {
                        type: "button",
                        onClick: handleRetry,
                        style: {
                            background: "transparent",
                            border: "1px solid #ef4444",
                            color: "#ef4444",
                            borderRadius: 4,
                            padding: "2px 6px",
                            fontSize: 10,
                            cursor: "pointer",
                            fontWeight: 500,
                        }
                    }, "Retry")
                ),

                open && items.length > 0 && React.createElement("div", {
                    role: "listbox",
                    "aria-label": "Port suggestions",
                    style: {
                        position: "absolute",
                        left: 0,
                        right: 0,
                        zIndex: 20,
                        background: "#0b1222",
                        border: "1px solid rgba(255,255,255,.12)",
                        borderRadius: 12,
                        maxHeight: 240,
                        overflowY: "auto",
                    }
                },
                    items.map((p, i) => {
                        const isActive = i === active;
                        const q = query.trim();
                        return React.createElement("div", {
                            key: `${p.locode}-${i}`,
                            role: "option",
                            "aria-selected": isActive,
                            onMouseDown: (e) => e.preventDefault(),
                            onClick: () => pick(p.locode),
                            onMouseEnter: () => setActive(i),
                            style: {
                                padding: "10px 12px",
                                cursor: "pointer",
                                background: isActive ? "#1e293b" : "transparent",
                                borderBottom: "1px solid rgba(255,255,255,.06)",
                            }
                        },
                            React.createElement("div", { 
                                style: { display: "flex", justifyContent: "space-between", alignItems: "center", gap: 12 }
                            },
                                React.createElement("div", { style: { flex: 1 } },
                                    React.createElement("div", { 
                                        style: { fontSize: "14px", fontWeight: 500, marginBottom: 2 }
                                    }, highlightMatch(p.name, q), ` (${p.country})`),
                                    React.createElement("div", { 
                                        style: { fontSize: "12px", color: "#94a3b8", fontFamily: "monospace" }
                                    }, p.locode)
                                ),
                                p.countryName && React.createElement("div", { 
                                    style: { fontSize: "12px", color: "#64748b", fontStyle: "italic" }
                                }, p.countryName)
                            )
                        );
                    })
                )
            );
        }

        function TestApp() {
            const [selectedPort, setSelectedPort] = useState("");
            const [selectedPort2, setSelectedPort2] = useState("");

            return React.createElement("div", null,
                React.createElement("h1", { 
                    style: { marginBottom: "24px", fontSize: "28px", fontWeight: 700 }
                }, "🔧 FIXED PortSelect Component Test"),
                
                React.createElement("div", { 
                    style: { marginBottom: "20px", padding: "16px", background: "#10b981", color: "#000", borderRadius: 12, fontWeight: 600 }
                }, "✅ FIXED: CORS issues, request loops, abort controller, and state management"),

                React.createElement("div", { 
                    style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "20px", marginBottom: "24px" }
                },
                    React.createElement("div", null,
                        React.createElement(PortSelect, {
                            label: "From Port",
                            value: selectedPort,
                            onChange: setSelectedPort,
                            placeholder: "Start typing a country, city, or LOCODE"
                        })
                    ),
                    React.createElement("div", null,
                        React.createElement(PortSelect, {
                            label: "To Port", 
                            value: selectedPort2,
                            onChange: setSelectedPort2,
                            placeholder: "Start typing a country, city, or LOCODE"
                        })
                    )
                ),

                React.createElement("div", { style: { marginTop: "20px", padding: "16px", background: "#0b1222", borderRadius: 12 } },
                    React.createElement("h3", { style: { marginTop: 0, color: "#3b82f6" } }, "Test Instructions:"),
                    React.createElement("ul", { style: { fontSize: "14px", lineHeight: 1.6 } },
                        React.createElement("li", null, "✅ Type 'alex' → should show Alexandria immediately"),
                        React.createElement("li", null, "✅ Use ↑/↓ arrow keys → should navigate smoothly"),
                        React.createElement("li", null, "✅ Press Enter or Tab → should select and close"),
                        React.createElement("li", null, "✅ Press Esc → should close dropdown"),
                        React.createElement("li", null, "✅ Type 'EGALY' directly → should show 'Valid UN/LOCODE'"),
                        React.createElement("li", null, "✅ No infinite loops → check browser console for no errors")
                    )
                ),

                React.createElement("div", { style: { marginTop: "20px", padding: "16px", background: "#0f172a", borderRadius: 12 } },
                    React.createElement("h3", { style: { marginTop: 0, color: "#10b981" } }, "Selected Values:"),
                    React.createElement("p", { style: { fontSize: "14px", fontFamily: "monospace" } },
                        "From Port: ", selectedPort || "(none)"
                    ),
                    React.createElement("p", { style: { fontSize: "14px", fontFamily: "monospace" } },
                        "To Port: ", selectedPort2 || "(none)"
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(TestApp));
    </script>
</body>
</html>